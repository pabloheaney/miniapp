<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>蒸汽深淵 Steam Shaft</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg-color: #1a1815;
            --frame-color: #5d4037;
            --accent-color: #d4a017;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #0f0e0d;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'VT323', monospace;
            touch-action: none; /* 防止手機上下滑動 */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 100%;
            max-height: 800px;
            background-color: var(--bg-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border: 4px solid #8d6e63;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* 關鍵：保持像素銳利 */
        }

        /* 復古 CRT 掃描線效果 */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* 邊框裝飾 */
        .gears-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.7);
            border: 2px solid rgba(212, 160, 23, 0.3);
            z-index: 11;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #e6c288;
            font-size: 24px;
            text-shadow: 2px 2px 0px #000;
            z-index: 5;
            pointer-events: none;
        }

        #hp-bar-container {
            margin-top: 5px;
            width: 100px;
            height: 10px;
            background: #333;
            border: 2px solid #5d4037;
        }

        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #b71c1c;
            transition: width 0.1s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="gears-overlay"></div>
    
    <div id="ui-layer" style="display: none;">
        <div>深淵層數: <span id="score">0</span>m</div>
        <div id="hp-bar-container"><div id="hp-bar-fill"></div></div>
    </div>
</div>

<script>
/**
 * 蒸汽深淵 (Steam Shaft)
 * 一款由 Vanilla JS + Canvas 打造的 NS-SHAFT 風格游戲
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // 優化渲染
const uiLayer = document.getElementById('ui-layer');
const scoreEl = document.getElementById('score');
const hpBarFill = document.getElementById('hp-bar-fill');

// 游戲常量
const GAME_WIDTH = 320;  // 內部邏輯寬度 (像素風格)
const GAME_HEIGHT = 480; // 內部邏輯高度
const GRAVITY = 0.4;
const FRICTION = 0.8;
const MOVE_SPEED = 5;
const MAX_FALL_SPEED = 8;
const PLATFORM_WIDTH = 70;
const PLATFORM_HEIGHT = 14;
const PLAYER_SIZE = 16;
const CEILING_DAMAGE_HEIGHT = 20; // 頂部尖刺區域高度

// 游戲狀態
let state = {
    mode: 'MENU', // MENU, PLAYING, GAMEOVER
    score: 0,
    difficulty: 1,
    frameCount: 0,
    lastTime: 0
};

// 輸入狀態
const input = {
    left: false,
    right: false
};

// 音效合成器 (簡單的嗶嗶聲，無需外部文件)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    if (type === 'jump') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'hurt') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
    } else if (type === 'step') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);
    }
}

// 實體類
class Player {
    constructor() {
        this.width = PLAYER_SIZE;
        this.height = PLAYER_SIZE;
        this.reset();
    }

    reset() {
        this.x = GAME_WIDTH / 2 - this.width / 2;
        this.y = 100;
        this.vx = 0;
        this.vy = 0;
        this.hp = 12;
        this.maxHp = 12;
        this.onGround = false;
        this.invincibleTimer = 0;
        this.animFrame = 0;
        this.faceRight = true;
    }

    update() {
        // 水平移動
        if (input.left) {
            this.vx = -MOVE_SPEED;
            this.faceRight = false;
            if (state.frameCount % 10 === 0 && this.onGround) playSound('step');
        } else if (input.right) {
            this.vx = MOVE_SPEED;
            this.faceRight = true;
            if (state.frameCount % 10 === 0 && this.onGround) playSound('step');
        } else {
            this.vx *= FRICTION;
        }

        // 應用速度
        this.x += this.vx;

        // 邊界檢查 (左右循環)
        if (this.x < -this.width / 2) this.x = GAME_WIDTH - this.width / 2;
        if (this.x > GAME_WIDTH - this.width / 2) this.x = -this.width / 2;

        // 重力
        if (!this.onGround) {
            this.vy += GRAVITY;
            if (this.vy > MAX_FALL_SPEED) this.vy = MAX_FALL_SPEED;
        }
        this.y += this.vy;

        // 頂部尖刺傷害
        if (this.y < CEILING_DAMAGE_HEIGHT) {
            this.hurt(4); // 頂部傷害很高
            this.y = CEILING_DAMAGE_HEIGHT + 2;
            this.vy = 2; // 被彈下來
            createParticles(this.x + this.width/2, this.y, '#b71c1c', 10);
        }

        // 底部死亡
        if (this.y > GAME_HEIGHT) {
            this.hp = 0;
        }

        // 無敵時間遞減
        if (this.invincibleTimer > 0) this.invincibleTimer--;

        // 更新UI
        hpBarFill.style.width = `${(this.hp / this.maxHp) * 100}%`;
    }

    hurt(amount) {
        if (this.invincibleTimer > 0) return;
        this.hp -= amount;
        this.invincibleTimer = 60; // 1秒無敵
        playSound('hurt');
        screenShake = 10;
        if (this.hp <= 0) this.hp = 0;
    }

    heal(amount) {
        this.hp += amount;
        if (this.hp > this.maxHp) this.hp = this.maxHp;
    }

    draw(ctx) {
        if (this.invincibleTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

        // 繪製蒸汽機器人 (簡單像素畫)
        ctx.save();
        ctx.translate(Math.round(this.x), Math.round(this.y));
        
        // 翻轉
        if (!this.faceRight) {
            ctx.translate(this.width, 0);
            ctx.scale(-1, 1);
        }

        // 身體 (銅色)
        ctx.fillStyle = '#cd7f32';
        ctx.fillRect(2, 4, 12, 12);
        
        // 頭部 (金色)
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(4, 0, 8, 8);
        
        // 眼睛 (護目鏡)
        ctx.fillStyle = '#00e5ff'; // 霓虹藍
        ctx.fillRect(8, 2, 4, 2);
        
        // 腳步動畫
        let legOffset = 0;
        if (Math.abs(this.vx) > 0.5) {
            legOffset = Math.sin(state.frameCount * 0.5) * 2;
        }
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(4 + legOffset, 14, 3, 2);
        ctx.fillRect(9 - legOffset, 14, 3, 2);

        // 蒸汽粒子
        if (state.frameCount % 10 === 0) {
            createParticles(this.x + (this.faceRight ? 0 : this.width), this.y + 10, 'rgba(200,200,200,0.5)', 1, true);
        }

        ctx.restore();
    }
}

class Platform {
    constructor(y) {
        this.w = PLATFORM_WIDTH;
        this.h = PLATFORM_HEIGHT;
        this.x = Math.random() * (GAME_WIDTH - this.w);
        this.y = y;
        // 平台類型: 
        // 0: 普通 (Normal) - 60%
        // 1: 尖刺 (Spikes) - 15%
        // 2: 傳送帶左 (Conveyor L) - 10%
        // 3: 傳送帶右 (Conveyor R) - 10%
        // 4: 易碎 (Fragile) - 5%
        const rand = Math.random();
        if (rand < 0.6) this.type = 0;
        else if (rand < 0.75) this.type = 1;
        else if (rand < 0.85) this.type = 2;
        else if (rand < 0.95) this.type = 3;
        else this.type = 4;

        this.touched = false; // 用於易碎平台
        this.active = true;
    }

    update(speed) {
        this.y -= speed;
        
        // 傳送帶動畫
        if (this.type === 2 || this.type === 3) {
            this.animOffset = (state.frameCount * 2) % 8;
        }
    }

    draw(ctx) {
        if (!this.active) return;
        let rx = Math.round(this.x);
        let ry = Math.round(this.y);

        ctx.fillStyle = '#000';
        // 陰影
        ctx.fillRect(rx + 2, ry + 2, this.w, this.h);

        switch (this.type) {
            case 0: // 普通 (生鏽鋼鐵)
                ctx.fillStyle = '#5d4037'; // 深棕框
                ctx.fillRect(rx, ry, this.w, this.h);
                ctx.fillStyle = '#8d6e63'; // 內部
                ctx.fillRect(rx + 1, ry + 1, this.w - 2, this.h - 2);
                // 鉚釘
                ctx.fillStyle = '#bcaaa4';
                ctx.fillRect(rx + 2, ry + 2, 2, 2);
                ctx.fillRect(rx + this.w - 4, ry + 2, 2, 2);
                break;
            case 1: // 尖刺 (黃銅危險)
                ctx.fillStyle = '#8d6e63';
                ctx.fillRect(rx, ry + 6, this.w, this.h - 6); // 底部基座
                // 畫刺
                ctx.fillStyle = '#ffd700'; // 金刺
                for(let i=0; i<this.w; i+=10) {
                    ctx.beginPath();
                    ctx.moveTo(rx + i, ry + 6);
                    ctx.lineTo(rx + i + 5, ry - 4);
                    ctx.lineTo(rx + i + 10, ry + 6);
                    ctx.fill();
                }
                break;
            case 2: // 傳送帶 左 (齒輪驅動)
            case 3: // 傳送帶 右
                ctx.fillStyle = '#37474f';
                ctx.fillRect(rx, ry, this.w, this.h);
                // 箭頭動畫
                ctx.fillStyle = '#cfd8dc';
                for(let i=0; i<this.w; i+=16) {
                    let offset = (this.type === 2) ? -this.animOffset : this.animOffset;
                    let xPos = (rx + i + offset);
                    if (xPos > rx && xPos < rx + this.w - 4) {
                       ctx.fillRect(xPos, ry + 4, 4, 6);
                    }
                }
                break;
            case 4: // 易碎 (玻璃/裂木)
                ctx.fillStyle = '#fff9c4';
                ctx.globalAlpha = 0.6;
                ctx.fillRect(rx, ry, this.w, this.h);
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(rx, ry, this.w, this.h);
                break;
        }
    }
}

// 粒子系統
let particles = [];
class Particle {
    constructor(x, y, color, speedY, isSteam) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 3 + 1;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2 - speedY;
        this.life = 30 + Math.random() * 20;
        this.isSteam = isSteam;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if (this.isSteam) {
            this.size += 0.1;
            this.vy -= 0.02; // 向上飄
        }
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / 50;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}
function createParticles(x, y, color, count, isSteam=false) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, isSteam ? 0 : 2, isSteam));
    }
}

// 全局變量
let player;
let platforms = [];
let screenShake = 0;
let platformSpeed = 2; // 基礎速度
let distanceTraveled = 0;

// 初始化
function init() {
    resize();
    player = new Player();
    platforms = [];
    state.score = 0;
    state.difficulty = 1;
    platformSpeed = 1.5;
    distanceTraveled = 0;
    
    // 生成初始平台
    for(let i=0; i<7; i++) {
        let p = new Platform(100 + i * 80);
        p.type = 0; // 開始全是普通平台
        platforms.push(p);
    }
    
    state.mode = 'MENU';
    uiLayer.style.display = 'none';
}

function startGame() {
    state.mode = 'PLAYING';
    state.score = 0;
    player.reset();
    uiLayer.style.display = 'block';
    
    // 清空並生成新平台
    platforms = [];
    for(let i=0; i<8; i++) {
        let p = new Platform(400 + i * 80);
        p.type = 0; 
        platforms.push(p);
    }
    // 讓玩家在第一個平台上
    platforms[0].x = GAME_WIDTH / 2 - PLATFORM_WIDTH/2;
    platforms[0].y = 350;
    player.x = GAME_WIDTH / 2 - PLAYER_SIZE/2;
    player.y = 300;
}

// 物理與邏輯更新
function update() {
    if (state.mode !== 'PLAYING') return;

    state.frameCount++;
    
    // 難度曲線：隨著分數提高，平台上升速度變快
    platformSpeed = 1.5 + (state.score / 500); 
    if (platformSpeed > 4) platformSpeed = 4;

    // 平台邏輯
    let lastY = 0;
    platforms.forEach(p => {
        p.update(platformSpeed);
        if (p.y > lastY) lastY = p.y;
    });

    // 移除超出頂部的平台
    platforms = platforms.filter(p => p.y + p.h > 0);

    // 生成新平台 (底部)
    if (lastY < GAME_HEIGHT - 60) { // 間距
        platforms.push(new Platform(GAME_HEIGHT));
    }

    // 玩家物理
    player.update();
    
    // 玩家與平台碰撞檢測
    player.onGround = false;
    // 預先假設玩家在移動
    let onConveyor = 0;

    if (player.vy >= 0) { // 只有下落時才檢測
        platforms.forEach(p => {
            if (!p.active) return;
            
            // 簡單AABB碰撞 (腳部檢測)
            if (player.x + player.width > p.x &&
                player.x < p.x + p.w &&
                player.y + player.height >= p.y &&
                player.y + player.height <= p.y + p.h + player.vy + 2 // 寬容度
               ) {
                
                // 碰到平台
                player.y = p.y - player.height;
                player.vy = -platformSpeed; // 玩家跟隨平台上升 (重要邏輯)
                player.onGround = true;

                if (p.type === 1) { // 尖刺
                    player.hurt(5);
                    player.vy = -4; // 彈起
                    createParticles(player.x, player.y + player.height, '#ffd700', 5);
                } else if (p.type === 2) { // 左傳送
                    player.x -= 2;
                    onConveyor = -1;
                } else if (p.type === 3) { // 右傳送
                    player.x += 2;
                    onConveyor = 1;
                } else if (p.type === 4) { // 易碎
                    if (!p.touched) {
                        p.touched = true;
                        playSound('step');
                        setTimeout(() => { p.active = false; createParticles(p.x + p.w/2, p.y, '#fff', 8); }, 200); // 0.2秒後消失
                    }
                } else {
                    // 普通平台，回血機制 (非常緩慢)
                    if (state.frameCount % 60 === 0) player.heal(1);
                }
            }
        });
    }

    // 計算分數 (存活越久/越深)
    if (state.frameCount % 10 === 0) state.score++;
    scoreEl.innerText = state.score;

    // 粒子更新
    particles.forEach((p, index) => {
        p.update();
        if (p.life <= 0) particles.splice(index, 1);
    });

    // 死亡檢測
    if (player.hp <= 0) {
        state.mode = 'GAMEOVER';
        playSound('hurt');
    }
}

// 渲染
function draw() {
    // 適配 Canvas 縮放
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    // 屏幕震動
    let shakeX = 0, shakeY = 0;
    if (screenShake > 0) {
        shakeX = (Math.random() - 0.5) * screenShake;
        shakeY = (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9;
        if (screenShake < 0.5) screenShake = 0;
    }

    // 清除背景
    ctx.fillStyle = '#1a1815';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 應用邏輯坐標系縮放
    let scale = canvas.width / GAME_WIDTH;
    ctx.scale(scale, scale);
    ctx.translate(shakeX, shakeY);

    // 繪製背景齒輪 (裝飾)
    drawBackgroundGears(ctx);

    // 繪製頂部危險區域
    ctx.fillStyle = '#3e2723';
    ctx.fillRect(0, 0, GAME_WIDTH, CEILING_DAMAGE_HEIGHT);
    // 頂部尖刺
    ctx.fillStyle = '#b71c1c';
    for(let i=0; i<GAME_WIDTH; i+=10) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i+5, CEILING_DAMAGE_HEIGHT);
        ctx.lineTo(i+10, 0);
        ctx.fill();
    }

    // 繪製平台
    platforms.forEach(p => p.draw(ctx));

    // 繪製粒子
    particles.forEach(p => p.draw(ctx));

    // 繪製玩家
    if (state.mode === 'PLAYING') {
        player.draw(ctx);
    }

    // UI層
    if (state.mode === 'MENU') {
        drawMenu();
    } else if (state.mode === 'GAMEOVER') {
        drawGameOver();
    }
}

function drawBackgroundGears(ctx) {
    ctx.save();
    ctx.fillStyle = '#2d241e';
    
    // 大齒輪
    let angle = state.frameCount * 0.01;
    drawGear(ctx, GAME_WIDTH/2, GAME_HEIGHT/2, 80, 12, angle);
    
    // 小齒輪
    drawGear(ctx, 40, 100, 30, 8, -angle * 2);
    drawGear(ctx, GAME_WIDTH - 40, GAME_HEIGHT - 100, 40, 8, -angle * 1.5);
    
    ctx.restore();
}

function drawGear(ctx, x, y, radius, teeth, angle) {
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    let outerRadius = radius;
    let innerRadius = radius - 10;
    for (let i = 0; i < teeth * 2; i++) {
        let r = (i % 2 === 0) ? outerRadius : innerRadius;
        let a = (Math.PI * 2 * i) / (teeth * 2);
        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
    }
    ctx.closePath();
    ctx.fill();
    
    // 中心孔
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    
    ctx.rotate(-angle);
    ctx.translate(-x, -y);
}

function drawMenu() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    ctx.fillStyle = '#ffd700';
    ctx.textAlign = 'center';
    ctx.font = '40px VT323';
    ctx.fillText('STEAM SHAFT', GAME_WIDTH/2, 150);
    
    ctx.fillStyle = '#fff';
    ctx.font = '20px VT323';
    ctx.fillText('點擊開始游戲', GAME_WIDTH/2, 250);
    
    ctx.fillStyle = '#8d6e63';
    ctx.font = '16px VT323';
    ctx.fillText('左/右點擊或方向鍵移動', GAME_WIDTH/2, 300);
    ctx.fillText('避開尖刺，不要掉落', GAME_WIDTH/2, 320);
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(50, 0, 0, 0.6)';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    ctx.fillStyle = '#ff5252';
    ctx.textAlign = 'center';
    ctx.font = '40px VT323';
    ctx.fillText('GAME OVER', GAME_WIDTH/2, 150);
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px VT323';
    ctx.fillText(`最終深度: ${state.score}m`, GAME_WIDTH/2, 220);
    
    if (state.frameCount % 60 < 30) {
        ctx.font = '20px VT323';
        ctx.fillText('點擊重試', GAME_WIDTH/2, 300);
    }
}

// 循環
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// 響應式處理
function resize() {
    // 保持長寬比
    const aspect = GAME_WIDTH / GAME_HEIGHT;
    let w = window.innerWidth;
    let h = window.innerHeight;
    
    if (w / h > aspect) {
        w = h * aspect;
    } else {
        h = w / aspect;
    }
    
    canvas.width = GAME_WIDTH;  // 內部渲染解析度固定
    canvas.height = GAME_HEIGHT;
}
window.addEventListener('resize', resize);

// 輸入監聽
window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') input.left = true;
    if (e.key === 'ArrowRight') input.right = true;
    
    if (state.mode !== 'PLAYING' && (e.key === ' ' || e.key === 'Enter')) {
        startGame();
    }
});

window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') input.left = false;
    if (e.key === 'ArrowRight') input.right = false;
});

// 觸控監聽
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (state.mode !== 'PLAYING') {
        startGame();
        return;
    }
    
    const rect = canvas.getBoundingClientRect();
    for (let i = 0; i < e.touches.length; i++) {
        let x = (e.touches[i].clientX - rect.left) / (rect.width / GAME_WIDTH);
        if (x < GAME_WIDTH / 2) input.left = true;
        else input.right = true;
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    // 簡單處理：如果沒有觸點了，就停止移動
    if (e.touches.length === 0) {
        input.left = false;
        input.right = false;
    } else {
        // 重新檢測剩餘觸點
        input.left = false;
        input.right = false;
        const rect = canvas.getBoundingClientRect();
        for (let i = 0; i < e.touches.length; i++) {
            let x = (e.touches[i].clientX - rect.left) / (rect.width / GAME_WIDTH);
            if (x < GAME_WIDTH / 2) input.left = true;
            else input.right = true;
        }
    }
});

// 鼠標點擊支持 (為了在電腦上用滑鼠測試)
canvas.addEventListener('mousedown', e => {
    if (state.mode !== 'PLAYING') {
        startGame();
        return;
    }
    const rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) / (rect.width / GAME_WIDTH);
    if (x < GAME_WIDTH / 2) input.left = true;
    else input.right = true;
});
canvas.addEventListener('mouseup', () => {
    input.left = false;
    input.right = false;
});

// 啟動
init();
loop();

</script>
</body>
</html>
