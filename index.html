<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>蒸汽深淵 Steam Shaft</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --bg-color: #1a1815;
            --frame-color: #5d4037;
            --accent-color: #d4a017;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #0f0e0d;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'VT323', monospace;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 100%;
            max-height: 800px;
            background-color: var(--bg-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border: 4px solid #8d6e63;
            overflow: hidden; /* 確保 UI 不會跑出去 */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* 復古 CRT 掃描線效果 */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        .gears-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.7);
            border: 2px solid rgba(212, 160, 23, 0.3);
            z-index: 11;
        }

        /* HUD 層 (分數與血量) */
        #hud-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .hud-text {
            color: #e6c288;
            font-size: 28px; /* 加大字體 */
            text-shadow: 2px 2px 0px #000;
            margin: 0;
            line-height: 1;
        }

        #hp-bar-container {
            width: 120px;
            height: 12px;
            background: #333;
            border: 2px solid #5d4037;
            position: relative;
        }

        #hp-bar-fill {
            width: 100%;
            height: 100%;
            background: #b71c1c;
            transition: width 0.1s;
        }

        /* 全螢幕覆蓋層 (選單與結束畫面) */
        .overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .overlay-layer.active {
            opacity: 1;
            pointer-events: auto; /* 允許點擊 */
        }

        .overlay-title {
            font-size: 64px;
            color: #ffd700;
            text-shadow: 4px 4px 0px #3e2723;
            margin: 0 0 20px 0;
            letter-spacing: 2px;
        }

        .overlay-subtitle {
            font-size: 32px;
            color: #e6c288;
            margin-bottom: 40px;
            text-shadow: 2px 2px 0px #000;
        }

        .instruction-box {
            background: rgba(93, 64, 55, 0.8);
            padding: 20px;
            border: 2px solid #d4a017;
            border-radius: 8px;
            margin-top: 20px;
        }

        .instruction-text {
            font-size: 20px;
            color: #fff;
            line-height: 1.5;
            margin: 5px 0;
        }

        .blink {
            animation: blinker 1.5s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }

        .btn-start {
            margin-top: 30px;
            padding: 10px 30px;
            font-family: 'VT323', monospace;
            font-size: 32px;
            color: #1a1815;
            background: #d4a017;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 4px 0 #8d6e63;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn-start:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #8d6e63;
        }

        /* 觸控區域提示 (僅在 Menu 顯示) */
        .touch-zones {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            opacity: 0.5;
            font-size: 18px;
            color: #aaa;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="gears-overlay"></div>
    
    <!-- HUD -->
    <div id="hud-layer" style="display: none;">
        <div class="hud-text">DEPTH: <span id="score">0</span>m</div>
        <div id="hp-bar-container"><div id="hp-bar-fill"></div></div>
    </div>

    <!-- 主選單 -->
    <div id="menu-layer" class="overlay-layer active">
        <div class="overlay-title">STEAM SHAFT</div>
        <div class="overlay-subtitle">蒸汽深淵</div>
        
        <button class="btn-start blink" onclick="startGame()">START GAME</button>
        
        <div class="instruction-box">
            <p class="instruction-text">← 左側點擊 / 右側點擊 →</p>
            <p class="instruction-text" style="color: #ff5252;">⚠ 避開尖刺與頂部 ⚠</p>
        </div>
    </div>

    <!-- 結束畫面 -->
    <div id="gameover-layer" class="overlay-layer">
        <div class="overlay-title" style="color: #ff5252;">GAME OVER</div>
        <div class="overlay-subtitle">最終深度: <span id="final-score">0</span>m</div>
        <button class="btn-start blink" onclick="startGame()">RETRY</button>
    </div>
</div>

<script>
/**
 * 蒸汽深淵 (Steam Shaft)
 * 更新：UI 分離版，文字清晰化
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const hudLayer = document.getElementById('hud-layer');
const menuLayer = document.getElementById('menu-layer');
const gameoverLayer = document.getElementById('gameover-layer');
const scoreEl = document.getElementById('score');
const finalScoreEl = document.getElementById('final-score');
const hpBarFill = document.getElementById('hp-bar-fill');

// 游戲常量
const GAME_WIDTH = 320;
const GAME_HEIGHT = 480;
const GRAVITY = 0.4;
const FRICTION = 0.8;
const MOVE_SPEED = 5;
const MAX_FALL_SPEED = 8;
const PLATFORM_WIDTH = 70;
const PLATFORM_HEIGHT = 14;
const PLAYER_SIZE = 16;
const CEILING_DAMAGE_HEIGHT = 20;

let state = {
    mode: 'MENU',
    score: 0,
    difficulty: 1,
    frameCount: 0
};

const input = {
    left: false,
    right: false
};

// 音效系統
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    if (type === 'jump') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    } else if (type === 'hurt') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
    } else if (type === 'step') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);
    }
}

class Player {
    constructor() {
        this.width = PLAYER_SIZE;
        this.height = PLAYER_SIZE;
        this.reset();
    }

    reset() {
        this.x = GAME_WIDTH / 2 - this.width / 2;
        this.y = 100;
        this.vx = 0;
        this.vy = 0;
        this.hp = 12;
        this.maxHp = 12;
        this.onGround = false;
        this.invincibleTimer = 0;
        this.faceRight = true;
    }

    update() {
        if (input.left) {
            this.vx = -MOVE_SPEED;
            this.faceRight = false;
            if (state.frameCount % 10 === 0 && this.onGround) playSound('step');
        } else if (input.right) {
            this.vx = MOVE_SPEED;
            this.faceRight = true;
            if (state.frameCount % 10 === 0 && this.onGround) playSound('step');
        } else {
            this.vx *= FRICTION;
        }

        this.x += this.vx;

        if (this.x < -this.width / 2) this.x = GAME_WIDTH - this.width / 2;
        if (this.x > GAME_WIDTH - this.width / 2) this.x = -this.width / 2;

        if (!this.onGround) {
            this.vy += GRAVITY;
            if (this.vy > MAX_FALL_SPEED) this.vy = MAX_FALL_SPEED;
        }
        this.y += this.vy;

        if (this.y < CEILING_DAMAGE_HEIGHT) {
            this.hurt(4);
            this.y = CEILING_DAMAGE_HEIGHT + 2;
            this.vy = 2;
            createParticles(this.x + this.width/2, this.y, '#b71c1c', 10);
        }

        if (this.y > GAME_HEIGHT) {
            this.hp = 0;
        }

        if (this.invincibleTimer > 0) this.invincibleTimer--;

        // UI 更新移出 update 循環，減少 DOM 操作頻率，或者僅在變化時更新
        // 為簡單起見，這裡每幀更新是可以的，但最好優化
        hpBarFill.style.width = `${(this.hp / this.maxHp) * 100}%`;
    }

    hurt(amount) {
        if (this.invincibleTimer > 0) return;
        this.hp -= amount;
        this.invincibleTimer = 60;
        playSound('hurt');
        screenShake = 10;
        if (this.hp <= 0) this.hp = 0;
    }

    heal(amount) {
        this.hp += amount;
        if (this.hp > this.maxHp) this.hp = this.maxHp;
    }

    draw(ctx) {
        if (this.invincibleTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

        ctx.save();
        ctx.translate(Math.round(this.x), Math.round(this.y));
        
        if (!this.faceRight) {
            ctx.translate(this.width, 0);
            ctx.scale(-1, 1);
        }

        ctx.fillStyle = '#cd7f32';
        ctx.fillRect(2, 4, 12, 12);
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(4, 0, 8, 8);
        ctx.fillStyle = '#00e5ff';
        ctx.fillRect(8, 2, 4, 2);
        
        let legOffset = 0;
        if (Math.abs(this.vx) > 0.5) {
            legOffset = Math.sin(state.frameCount * 0.5) * 2;
        }
        ctx.fillStyle = '#5d4037';
        ctx.fillRect(4 + legOffset, 14, 3, 2);
        ctx.fillRect(9 - legOffset, 14, 3, 2);

        if (state.frameCount % 10 === 0) {
            createParticles(this.x + (this.faceRight ? 0 : this.width), this.y + 10, 'rgba(200,200,200,0.5)', 1, true);
        }

        ctx.restore();
    }
}

class Platform {
    constructor(y) {
        this.w = PLATFORM_WIDTH;
        this.h = PLATFORM_HEIGHT;
        this.x = Math.random() * (GAME_WIDTH - this.w);
        this.y = y;
        const rand = Math.random();
        if (rand < 0.6) this.type = 0;
        else if (rand < 0.75) this.type = 1;
        else if (rand < 0.85) this.type = 2;
        else if (rand < 0.95) this.type = 3;
        else this.type = 4;

        this.touched = false;
        this.active = true;
        this.animOffset = 0;
    }

    update(speed) {
        this.y -= speed;
        if (this.type === 2 || this.type === 3) {
            // 動畫速度加倍
            this.animOffset = (state.frameCount * 4) % 16;
        }
    }

    draw(ctx) {
        if (!this.active) return;
        let rx = Math.round(this.x);
        let ry = Math.round(this.y);

        ctx.fillStyle = '#000';
        ctx.fillRect(rx + 2, ry + 2, this.w, this.h);

        switch (this.type) {
            case 0:
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(rx, ry, this.w, this.h);
                ctx.fillStyle = '#8d6e63';
                ctx.fillRect(rx + 1, ry + 1, this.w - 2, this.h - 2);
                ctx.fillStyle = '#bcaaa4';
                ctx.fillRect(rx + 2, ry + 2, 2, 2);
                ctx.fillRect(rx + this.w - 4, ry + 2, 2, 2);
                break;
            case 1:
                ctx.fillStyle = '#8d6e63';
                ctx.fillRect(rx, ry + 6, this.w, this.h - 6);
                ctx.fillStyle = '#ffd700';
                for(let i=0; i<this.w; i+=10) {
                    ctx.beginPath();
                    ctx.moveTo(rx + i, ry + 6);
                    ctx.lineTo(rx + i + 5, ry - 4);
                    ctx.lineTo(rx + i + 10, ry + 6);
                    ctx.fill();
                }
                break;
            case 2:
            case 3:
                ctx.fillStyle = '#37474f';
                ctx.fillRect(rx, ry, this.w, this.h);
                ctx.fillStyle = '#cfd8dc';
                for(let i=0; i<this.w; i+=16) {
                    let offset = (this.type === 2) ? -this.animOffset : this.animOffset;
                    let xPos = (rx + i + offset);
                    if (xPos > rx && xPos < rx + this.w - 4) {
                       ctx.fillRect(xPos, ry + 4, 4, 6);
                    }
                }
                break;
            case 4:
                ctx.fillStyle = '#fff9c4';
                ctx.globalAlpha = 0.6;
                ctx.fillRect(rx, ry, this.w, this.h);
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(rx, ry, this.w, this.h);
                break;
        }
    }
}

let particles = [];
class Particle {
    constructor(x, y, color, speedY, isSteam) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 3 + 1;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2 - speedY;
        this.life = 30 + Math.random() * 20;
        this.isSteam = isSteam;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        if (this.isSteam) {
            this.size += 0.1;
            this.vy -= 0.02;
        }
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / 50;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}
function createParticles(x, y, color, count, isSteam=false) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color, isSteam ? 0 : 2, isSteam));
    }
}

let player;
let platforms = [];
let screenShake = 0;
let platformSpeed = 2;

function init() {
    resize();
    player = new Player();
    platforms = [];
    state.score = 0;
    
    // 背景平台
    for(let i=0; i<7; i++) {
        let p = new Platform(100 + i * 80);
        p.type = 0;
        platforms.push(p);
    }
    
    showMenu();
}

function showMenu() {
    state.mode = 'MENU';
    menuLayer.classList.add('active');
    gameoverLayer.classList.remove('active');
    hudLayer.style.display = 'none';
}

function showGameOver() {
    state.mode = 'GAMEOVER';
    gameoverLayer.classList.add('active');
    hudLayer.style.display = 'none';
    finalScoreEl.innerText = state.score;
}

// 暴露給全局以便 HTML 按鈕調用
window.startGame = function() {
    state.mode = 'PLAYING';
    state.score = 0;
    player.reset();
    
    // 隱藏選單
    menuLayer.classList.remove('active');
    gameoverLayer.classList.remove('active');
    hudLayer.style.display = 'flex';
    
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    platforms = [];
    for(let i=0; i<8; i++) {
        let p = new Platform(400 + i * 80);
        p.type = 0; 
        platforms.push(p);
    }
    platforms[0].x = GAME_WIDTH / 2 - PLATFORM_WIDTH/2;
    platforms[0].y = 350;
    player.x = GAME_WIDTH / 2 - PLAYER_SIZE/2;
    player.y = 300;
};

function update() {
    if (state.mode !== 'PLAYING') return;

    state.frameCount++;
    
    platformSpeed = 1.5 + (state.score / 500); 
    if (platformSpeed > 4) platformSpeed = 4;

    let lastY = 0;
    platforms.forEach(p => {
        p.update(platformSpeed);
        if (p.y > lastY) lastY = p.y;
    });

    platforms = platforms.filter(p => p.y + p.h > 0);

    if (lastY < GAME_HEIGHT - 60) {
        platforms.push(new Platform(GAME_HEIGHT));
    }

    player.update();
    
    player.onGround = false;
    if (player.vy >= 0) {
        platforms.forEach(p => {
            if (!p.active) return;
            
            if (player.x + player.width > p.x &&
                player.x < p.x + p.w &&
                player.y + player.height >= p.y &&
                player.y + player.height <= p.y + p.h + player.vy + 2
               ) {
                
                player.y = p.y - player.height;
                player.vy = -platformSpeed;
                player.onGround = true;

                if (p.type === 1) {
                    player.hurt(5);
                    player.vy = -4;
                    createParticles(player.x, player.y + player.height, '#ffd700', 5);
                } else if (p.type === 2) {
                    player.x -= 4; // 左傳送速度加倍 (原為 2)
                } else if (p.type === 3) {
                    player.x += 4; // 右傳送速度加倍 (原為 2)
                } else if (p.type === 4) {
                    if (!p.touched) {
                        p.touched = true;
                        playSound('step');
                        setTimeout(() => { p.active = false; createParticles(p.x + p.w/2, p.y, '#fff', 8); }, 200);
                    }
                } else {
                    if (state.frameCount % 60 === 0) player.heal(1);
                }
            }
        });
    }

    if (state.frameCount % 10 === 0) {
        state.score++;
        scoreEl.innerText = state.score;
    }

    particles.forEach((p, index) => {
        p.update();
        if (p.life <= 0) particles.splice(index, 1);
    });

    if (player.hp <= 0) {
        showGameOver();
        playSound('hurt');
    }
}

function draw() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    let shakeX = 0, shakeY = 0;
    if (screenShake > 0) {
        shakeX = (Math.random() - 0.5) * screenShake;
        shakeY = (Math.random() - 0.5) * screenShake;
        screenShake *= 0.9;
        if (screenShake < 0.5) screenShake = 0;
    }

    ctx.fillStyle = '#1a1815';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let scale = canvas.width / GAME_WIDTH;
    ctx.scale(scale, scale);
    ctx.translate(shakeX, shakeY);

    drawBackgroundGears(ctx);

    ctx.fillStyle = '#3e2723';
    ctx.fillRect(0, 0, GAME_WIDTH, CEILING_DAMAGE_HEIGHT);
    ctx.fillStyle = '#b71c1c';
    for(let i=0; i<GAME_WIDTH; i+=10) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i+5, CEILING_DAMAGE_HEIGHT);
        ctx.lineTo(i+10, 0);
        ctx.fill();
    }

    platforms.forEach(p => p.draw(ctx));
    particles.forEach(p => p.draw(ctx));

    if (state.mode === 'PLAYING') {
        player.draw(ctx);
    }
}

function drawBackgroundGears(ctx) {
    ctx.save();
    ctx.fillStyle = '#2d241e';
    let angle = state.frameCount * 0.01;
    drawGear(ctx, GAME_WIDTH/2, GAME_HEIGHT/2, 80, 12, angle);
    drawGear(ctx, 40, 100, 30, 8, -angle * 2);
    drawGear(ctx, GAME_WIDTH - 40, GAME_HEIGHT - 100, 40, 8, -angle * 1.5);
    ctx.restore();
}

function drawGear(ctx, x, y, radius, teeth, angle) {
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    let outerRadius = radius;
    let innerRadius = radius - 10;
    for (let i = 0; i < teeth * 2; i++) {
        let r = (i % 2 === 0) ? outerRadius : innerRadius;
        let a = (Math.PI * 2 * i) / (teeth * 2);
        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
    }
    ctx.closePath();
    ctx.fill();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.rotate(-angle);
    ctx.translate(-x, -y);
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

function resize() {
    const aspect = GAME_WIDTH / GAME_HEIGHT;
    let w = window.innerWidth;
    let h = window.innerHeight;
    
    if (w / h > aspect) {
        w = h * aspect;
    } else {
        h = w / aspect;
    }
    
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
}
window.addEventListener('resize', resize);

window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') input.left = true;
    if (e.key === 'ArrowRight') input.right = true;
    
    if (state.mode !== 'PLAYING' && (e.key === ' ' || e.key === 'Enter')) {
        startGame();
    }
});

window.addEventListener('keyup', e => {
    if (e.key === 'ArrowLeft') input.left = false;
    if (e.key === 'ArrowRight') input.right = false;
});

// 觸控邏輯：只在非 Menu/GameOver 層 active 時監聽 Canvas
// 或者讓 Menu 層 pointer-events: auto，但按鈕外可以透傳？
// 這裡簡單處理：直接監聽 window 或 canvas，並計算區域
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if (state.mode !== 'PLAYING') return; // 選單有自己的按鈕
    
    const rect = canvas.getBoundingClientRect();
    for (let i = 0; i < e.touches.length; i++) {
        let x = (e.touches[i].clientX - rect.left) / (rect.width / GAME_WIDTH);
        if (x < GAME_WIDTH / 2) input.left = true;
        else input.right = true;
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (e.touches.length === 0) {
        input.left = false;
        input.right = false;
    } else {
        input.left = false;
        input.right = false;
        const rect = canvas.getBoundingClientRect();
        for (let i = 0; i < e.touches.length; i++) {
            let x = (e.touches[i].clientX - rect.left) / (rect.width / GAME_WIDTH);
            if (x < GAME_WIDTH / 2) input.left = true;
            else input.right = true;
        }
    }
});

canvas.addEventListener('mousedown', e => {
    if (state.mode !== 'PLAYING') return;
    const rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) / (rect.width / GAME_WIDTH);
    if (x < GAME_WIDTH / 2) input.left = true;
    else input.right = true;
});
canvas.addEventListener('mouseup', () => {
    input.left = false;
    input.right = false;
});

init();
loop();
</script>
</body>
</html>
